; let and letrec bindings in FluentAI
; Demonstrates different binding forms and scoping

; Basic let binding
(let ((x 10)
      (y 20))
  (print "x =" x ", y =" y)
  (print "x + y =" (+ x y)))

; Nested let bindings
(let ((x 5))
  (print "Outer x =" x)
  (let ((x 10)
        (y (* x 2)))  ; y uses outer x
    (print "Inner x =" x ", y =" y))
  (print "Outer x again =" x))

; Sequential binding with let*
; (each binding can refer to previous ones)
(let ((x 10)
      (y (* x 2))      ; Can reference x
      (z (+ x y)))     ; Can reference both x and y
  (print "x =" x ", y =" y ", z =" z))

; letrec for recursive definitions
(letrec ((factorial
          (lambda (n)
            (if (<= n 1)
                1
                (* n (factorial (- n 1)))))))
  (print "5! =" (factorial 5)))

; Mutually recursive functions with letrec
(letrec ((even?
          (lambda (n)
            (if (= n 0)
                true
                (odd? (- n 1)))))
         (odd?
          (lambda (n)
            (if (= n 0)
                false
                (even? (- n 1))))))
  (print "even?(10) =" (even? 10))
  (print "odd?(10) =" (odd? 10)))

; Complex letrec example - recursive data structure builders
(letrec ((make-list
          (lambda (n)
            (if (= n 0)
                (list)
                (cons n (make-list (- n 1))))))
         (sum-list
          (lambda (lst)
            (match lst
              ((Nil) 0)
              ((Cons x xs) (+ x (sum-list xs))))))
         (double-list
          (lambda (lst)
            (match lst
              ((Nil) (list))
              ((Cons x xs) (cons (* x 2) (double-list xs)))))))
  (let ((nums (make-list 5)))
    (print "Generated list:" nums)
    (print "Sum:" (sum-list nums))
    (print "Doubled:" (double-list nums))))

; Closure capture with let
(let ((make-counter
       (lambda (initial)
         (let ((count initial))
           (lambda (op)
             (match op
               ("get" count)
               ("inc" (begin
                       (set! count (+ count 1))
                       count))
               ("reset" (begin
                         (set! count initial)
                         count))))))))
  (let ((counter (make-counter 0)))
    (print "Initial:" (counter "get"))
    (print "After inc:" (counter "inc"))
    (print "After inc:" (counter "inc"))
    (print "After reset:" (counter "reset"))))

; Demonstrating scope differences
(let ((x 1))
  (let ((f (lambda () x))     ; Captures x=1
        (x 2))                 ; Shadows x
    (print "f() returns:" (f))  ; Returns 1, not 2
    (print "x is:" x)))         ; x is 2 here

; letrec with initialization order
(letrec ((a 10)
         (b (* a 2))           ; Can reference a
         (c (+ a b))           ; Can reference both a and b
         (compute
          (lambda ()
            (+ a b c))))       ; Can reference all bindings
  (print "a =" a ", b =" b ", c =" c)
  (print "compute() =" (compute)))

; Named let for loops
(let loop ((n 10)
           (acc 0))
  (if (= n 0)
      (print "Sum 1..10 =" acc)
      (loop (- n 1) (+ acc n))))