; Effect system demonstration in FluentAI
; Shows how to use various effects and handlers

; Basic IO effect
(effect io print-line "Hello from FluentAI!")

; Reading input
(print "What's your name?")
(let ((name (effect io read-line)))
  (effect io print-line (str-concat "Hello, " name "!")))

; File operations
(handler
  ((io (lambda (op . args)
         (match op
           ("read-file" 
             (print "Reading file:" (first args))
             "File contents here")
           ("write-file"
             (print "Writing to file:" (first args))
             (print "Content:" (second args))
             true)
           (_ (apply effect io op args))))))
  
  (let ((content (effect io read-file "/tmp/test.txt")))
    (print "File content:" content)
    (effect io write-file "/tmp/output.txt" "New content")))

; State effect
(handler
  ((state (lambda (op . args)
            (match op
              ("get" 
                (print "Getting state for:" (first args))
                42)
              ("set"
                (print "Setting" (first args) "to" (second args))
                nil)
              (_ (apply effect state op args))))))
  
  (let ((count (effect state get "counter")))
    (print "Current count:" count)
    (effect state set "counter" (+ count 1))))

; Error handling
(handler
  ((error (lambda (err)
            (print "Caught error:" (get err :message))
            "default-value")))
  
  (let ((result (if (< 1 0)
                    "impossible"
                    (effect error raise "Something went wrong"))))
    (print "Result after error handling:" result)))

; Time effect
(let ((start (effect time now)))
  (print "Current time:" start)
  (effect time sleep 1000)  ; Sleep for 1 second
  (let ((end (effect time now)))
    (print "Time elapsed:" (- end start) "ms")))

; Network effect (simulated)
(handler
  ((network (lambda (op . args)
              (match op
                ("fetch"
                  (print "Fetching URL:" (first args))
                  {:status 200 :body "Response data"})
                ("post"
                  (print "POST to:" (first args))
                  (print "Data:" (second args))
                  {:status 201 :body "Created"})
                (_ (apply effect network op args))))))
  
  (let ((response (effect network fetch "https://api.example.com/data")))
    (print "Response status:" (get response :status))
    (print "Response body:" (get response :body))))

; Combining multiple effects
(handler
  ((io (lambda (op . args)
         (match op
           ("print-line" 
             (print "[IO]" (first args))
             nil)
           (_ (apply effect io op args)))))
   (state (lambda (op . args)
            (match op
              ("get" 0)  ; Initial state
              ("set" nil)
              (_ (apply effect state op args))))))
  
  (let ((counter (effect state get "visits")))
    (effect io print-line (str-concat "Visit count: " (to-string counter)))
    (effect state set "visits" (+ counter 1))))

; Custom effect definition
(handler
  ((logger (lambda (level message)
             (let ((timestamp (effect time now)))
               (print (str-concat "[" (to-string timestamp) "] " 
                                level ": " message))))))
  
  (effect logger "INFO" "Application started")
  (effect logger "DEBUG" "Processing data...")
  (effect logger "ERROR" "Something went wrong!"))

; Effect composition with nested handlers
(handler
  ((outer (lambda (op . args)
            (print "Outer handler:" op)
            (handler
              ((inner (lambda (op2 . args2)
                        (print "Inner handler:" op2)
                        "inner-result")))
              (effect inner "nested-operation")))))
  
  (effect outer "top-level"))