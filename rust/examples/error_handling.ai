; Error handling in FluentAI
; Demonstrates various approaches to error handling

; Using Result type with pattern matching
(let ((safe-divide
       (lambda (x y)
         (if (= y 0)
             (Error "Division by zero")
             (Ok (/ x y))))))
  
  (match (safe-divide 10 2)
    ((Ok result) (print "10 / 2 =" result))
    ((Error msg) (print "Error:" msg)))
  
  (match (safe-divide 10 0)
    ((Ok result) (print "10 / 0 =" result))
    ((Error msg) (print "Error:" msg))))

; Using handlers for error recovery
(handler
  ((error (lambda (err)
            (print "Caught error:" (get err :message))
            (print "Recovering with default value...")
            42)))
  
  (let ((result
         (let ((x 10) (y 0))
           (if (= y 0)
               (effect error raise {:message "Cannot divide by zero"
                                   :numerator x
                                   :denominator y})
               (/ x y)))))
    (print "Result after error handling:" result)))

; Chain of operations with error propagation
(let ((parse-int
       (lambda (str)
         (if (string? str)
             (Ok (string->int str))  ; Assuming this exists
             (Error "Not a string"))))
      
      (validate-positive
       (lambda (result)
         (match result
           ((Ok n) 
            (if (> n 0)
                (Ok n)
                (Error "Number must be positive")))
           ((Error msg) (Error msg)))))
      
      (double-if-valid
       (lambda (result)
         (match result
           ((Ok n) (Ok (* n 2)))
           ((Error msg) (Error msg))))))
  
  (let ((input "5"))
    (print "Processing" input ":")
    (let ((result (double-if-valid 
                   (validate-positive 
                    (parse-int input)))))
      (match result
        ((Ok value) (print "Success:" value))
        ((Error msg) (print "Failed:" msg))))))

; Multiple error types
(handler
  ((error (lambda (err)
            (let ((type (get err :type)))
              (match type
                ("network" 
                  (print "Network error, retrying...")
                  "retry-result")
                ("validation"
                  (print "Validation failed:" (get err :details))
                  "default-value")
                ("fatal"
                  (print "Fatal error, cannot recover!")
                  (effect error reraise err))
                (_
                  (print "Unknown error type:" type)
                  nil))))))
  
  (effect error raise {:type "network" 
                      :message "Connection timeout"})
  (effect error raise {:type "validation"
                      :details "Invalid email format"})
  ; This would propagate up:
  ; (effect error raise {:type "fatal" :message "Out of memory"}))

; Try-with-resources pattern
(let ((with-file
       (lambda (filename f)
         (handler
           ((error (lambda (err)
                     (print "Error in file operation:" 
                           (get err :message))
                     (print "Cleaning up file:" filename)
                     nil)))
           (print "Opening file:" filename)
           (let ((result (f filename)))
             (print "Closing file:" filename)
             result)))))
  
  (with-file "/tmp/data.txt"
    (lambda (file)
      (print "Processing file:" file)
      ; Simulate an error
      (effect error raise {:message "Read error"}))))

; Monadic error handling style
(let ((bind-result
       (lambda (result f)
         (match result
           ((Ok value) (f value))
           ((Error msg) (Error msg)))))
      
      (return-ok
       (lambda (value) (Ok value)))
      
      (return-error
       (lambda (msg) (Error msg))))
  
  ; Chain operations monadically
  (let ((compute
         (lambda (x)
           (bind-result (return-ok x)
             (lambda (a)
               (bind-result (if (> a 0)
                               (return-ok (* a 2))
                               (return-error "Must be positive"))
                 (lambda (b)
                   (bind-result (if (< b 100)
                                   (return-ok (+ b 10))
                                   (return-error "Too large"))
                     (lambda (c)
                       (return-ok c))))))))))
    
    (print "compute(5):" (compute 5))
    (print "compute(-5):" (compute -5))
    (print "compute(50):" (compute 50))))