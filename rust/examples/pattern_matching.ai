; Comprehensive pattern matching examples in FluentAI
; Demonstrates various pattern matching capabilities

; Basic literal matching
(let ((value 42))
  (match value
    (0 (print "Zero"))
    (1 (print "One"))
    (42 (print "The answer!"))
    (_ (print "Something else"))))

; Variable binding
(let ((point (list 3 4)))
  (match point
    ((Cons x (Cons y Nil))
      (print "Point coordinates: x =" x ", y =" y))))

; Wildcard patterns
(let ((data (list 1 2 3 4)))
  (match data
    ((Nil) (print "Empty"))
    ((Cons _ _) (print "Non-empty list"))))

; Nested pattern matching
(let ((nested (list (list 1 2) (list 3 4))))
  (match nested
    ((Cons (Cons a (Cons b Nil)) rest)
      (print "First pair:" a "," b))))

; Constructor patterns (algebraic data types)
(let ((result (Ok 42)))
  (match result
    ((Ok value) (print "Success:" value))
    ((Error msg) (print "Error:" msg))))

; As-patterns (binding the whole value)
(let ((lst (list 1 2 3)))
  (match lst
    ((as whole (Cons x xs))
      (print "First element:" x)
      (print "Whole list:" whole))))

; Guard patterns (with conditions)
(let ((num 15))
  (match num
    ((as n (when (> n 20))) (print n "is greater than 20"))
    ((as n (when (> n 10))) (print n "is greater than 10"))
    ((as n (when (> n 0))) (print n "is positive"))
    (_ (print "Non-positive"))))

; List pattern matching examples
(letrec ((describe-list
          (lambda (lst)
            (match lst
              ((Nil) "Empty list")
              ((Cons x Nil) "Single element list")
              ((Cons x (Cons y Nil)) "Two element list")
              ((Cons x (Cons y (Cons z xs))) "Three or more elements")))))
  (print (describe-list (list)))
  (print (describe-list (list 1)))
  (print (describe-list (list 1 2)))
  (print (describe-list (list 1 2 3 4 5))))

; Recursive patterns for tree structures
(letrec ((sum-tree
          (lambda (tree)
            (match tree
              ((Leaf n) n)
              ((Node left right) 
                (+ (sum-tree left) (sum-tree right)))))))
  ; Example tree: Node(Leaf(1), Node(Leaf(2), Leaf(3)))
  (let ((tree (Node (Leaf 1) (Node (Leaf 2) (Leaf 3)))))
    (print "Tree sum:" (sum-tree tree))))

; Multiple pattern matching (match on multiple values)
(let ((x 1) (y 2))
  (match (list x y)
    ((Cons 0 (Cons 0 Nil)) (print "Origin"))
    ((Cons 0 (Cons _ Nil)) (print "On Y-axis"))
    ((Cons _ (Cons 0 Nil)) (print "On X-axis"))
    (_ (print "Somewhere else"))))

; Pattern matching in function definitions
(letrec ((factorial
          (lambda (n)
            (match n
              (0 1)
              (1 1)
              (_ (* n (factorial (- n 1))))))))
  (print "5! =" (factorial 5)))