;; test-basic.fl - Basic validation test for IoT demo concepts
;; This tests core functionality before running the full demo

;; Test 1: Basic data types
(define test-sensor-reading
  (make-tagged "sensor-reading" "temp-001" 1000 25.5 (make-map "type" "temperature")))

(effect io print-line "Test 1: Basic sensor reading creation")
(effect io print-line (string-format "Created: {}" test-sensor-reading))
(effect io print-line "")

;; Test 2: Simple map/filter operations
(define test-data
  [(make-tagged "sensor-reading" "temp-001" 1000 25.5 (make-map "type" "temperature"))
   (make-tagged "sensor-reading" "temp-002" 1100 45.0 (make-map "type" "temperature"))  ; Anomaly
   (make-tagged "sensor-reading" "temp-003" 1200 22.0 (make-map "type" "temperature"))])

(effect io print-line "Test 2: Map/Filter operations")
(effect io print-line "Original data count: 3")

;; Simple filter for high temperatures
(define filtered 
  (filter (lambda (reading)
           (> (list-ref (tagged-values reading) 2) 40.0))
          test-data))

(effect io print-line (string-format "Filtered anomalies: {}" (length filtered)))
(effect io print-line "")

;; Test 3: Basic contract validation
(effect io print-line "Test 3: Contract validation")

(define (validate-reading reading)
  (and (tagged? reading)
       (eq? (tagged-tag reading) "sensor-reading")
       (= (length (tagged-values reading)) 4)))

(define all-valid? 
  (all? validate-reading test-data))

(effect io print-line (string-format "All readings valid: {}" all-valid?))
(effect io print-line "")

;; Test 4: Simple optimization demonstration
(effect io print-line "Test 4: Optimization concept")

;; Naive version - separate map and filter
(define (process-naive data)
  (let ((enriched (map (lambda (r) r) data)))  ; Identity map for demo
    (filter (lambda (r) 
             (> (list-ref (tagged-values r) 2) 40.0))
            enriched)))

;; Optimized version - fused map-filter
(define (process-optimized data)
  (fold-left (lambda (acc reading)
              (if (> (list-ref (tagged-values reading) 2) 40.0)
                  (cons reading acc)
                  acc))
            []
            data))

(effect io print-line "Both versions produce same result:")
(effect io print-line (string-format "Naive: {} anomalies" (length (process-naive test-data))))
(effect io print-line (string-format "Optimized: {} anomalies" (length (process-optimized test-data))))
(effect io print-line "")

;; Test 5: Basic channel simulation (if supported)
(effect io print-line "Test 5: Channel concept (mock)")

;; Mock channel using a list
(define mock-channel (atom []))

(define (mock-send ch val)
  (ch 'swap! (lambda (lst) (append lst [val]))))

(define (mock-receive ch)
  (let ((vals (ch 'get)))
    (if (null? vals)
        nil
        (begin
          (ch 'set! (cdr vals))
          (car vals)))))

;; Test mock channel
(mock-send mock-channel "data1")
(mock-send mock-channel "data2")
(effect io print-line (string-format "Received: {}" (mock-receive mock-channel)))
(effect io print-line (string-format "Received: {}" (mock-receive mock-channel)))
(effect io print-line (string-format "Received: {}" (mock-receive mock-channel)))  ; Should be nil
(effect io print-line "")

;; Helper functions that might be missing
(define (all? pred lst)
  (if (null? lst)
      true
      (and (pred (car lst))
           (all? pred (cdr lst)))))

(define (atom initial)
  (let ((value initial))
    (lambda (op . args)
      (cond
        ((eq? op 'get) value)
        ((eq? op 'set!) (set! value (car args)))
        ((eq? op 'swap!) (set! value ((car args) value)))))))

(effect io print-line "Basic tests completed!")
(effect io print-line "If all tests passed, the full demo should work with minor adjustments.")