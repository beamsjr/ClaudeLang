;; iot-streams.fl - Core stream processing abstractions for IoT data
;; This module provides efficient stream processing primitives

(module iot-streams
  (export make-stream
          stream-from-list
          stream-take
          stream-map
          stream-filter
          stream-window
          stream-fold
          stream-collect
          stream-pipe
          |>)

  ;; Stream representation using channels for async processing
  ;; A stream is a channel that produces values over time
  
  ;; Create a new stream from a generator function
  ;; The generator should return nil when done
  (define (make-stream generator)
    (let ((ch (make-channel)))
      (spawn 
        (letrec ((loop (lambda ()
                        (let ((val (generator)))
                          (if (nil? val)
                              (close-channel ch)
                              (begin
                                (send ch val)
                                (loop)))))))
          (loop)))
      ch))
  
  ;; Convert a list to a stream
  (define (stream-from-list lst)
    (make-stream
      (let ((remaining lst))
        (lambda ()
          (if (null? remaining)
              nil
              (let ((val (car remaining)))
                (set! remaining (cdr remaining))
                val))))))
  
  ;; Take n elements from a stream
  (define (stream-take n stream)
    (make-stream
      (let ((count 0))
        (lambda ()
          (if (>= count n)
              nil
              (let ((val (receive stream)))
                (set! count (+ count 1))
                val))))))
  
  ;; Transform stream elements with a function
  (define (stream-map f stream)
    (make-stream
      (lambda ()
        (let ((val (receive stream)))
          (if (nil? val)
              nil
              (f val))))))
  
  ;; Filter stream elements with a predicate
  (define (stream-filter pred stream)
    (make-stream
      (lambda ()
        (letrec ((get-next (lambda ()
                            (let ((val (receive stream)))
                              (cond
                                ((nil? val) nil)
                                ((pred val) val)
                                (else (get-next)))))))
          (get-next)))))
  
  ;; Create sliding windows of size n
  (define (stream-window n stream)
    (make-stream
      (let ((window []))
        (lambda ()
          (if (< (length window) n)
              ;; Fill initial window
              (letrec ((fill (lambda ()
                              (let ((val (receive stream)))
                                (if (nil? val)
                                    (if (null? window) nil window)
                                    (begin
                                      (set! window (append window [val]))
                                      (if (< (length window) n)
                                          (fill)
                                          window)))))))
                (fill))
              ;; Slide window
              (let ((val (receive stream)))
                (if (nil? val)
                    nil
                    (begin
                      (set! window (append (cdr window) [val]))
                      window))))))))
  
  ;; Fold over a stream
  (define (stream-fold f init stream)
    (letrec ((loop (lambda (acc)
                    (let ((val (receive stream)))
                      (if (nil? val)
                          acc
                          (loop (f acc val)))))))
      (loop init)))
  
  ;; Collect stream into a list
  (define (stream-collect stream)
    (stream-fold (lambda (acc val) (append acc [val])) [] stream))
  
  ;; Pipe operator for composing stream operations
  (define (stream-pipe stream . ops)
    (fold-left (lambda (s op) (op s)) stream ops))
  
  ;; Infix pipe operator (syntactic sugar)
  (define-syntax |>
    (syntax-rules ()
      ((|> expr) expr)
      ((|> expr op rest ...)
       (|> (op expr) rest ...))))))