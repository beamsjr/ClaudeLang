;; iot-benchmark.fl - Performance benchmarking utilities
;; Measures throughput and performance of different pipeline implementations

(module iot-benchmark
  (import iot-types)
  (import iot-pipeline)
  (import iot-streams)
  
  (export benchmark-pipeline
          generate-sensor-data
          measure-throughput
          compare-implementations
          print-benchmark-results)

  ;; Benchmark configuration
  (define *default-data-size* 10000)
  (define *warmup-iterations* 3)
  (define *benchmark-iterations* 10)
  
  ;; Main benchmarking function
  (define (benchmark-pipeline pipeline-fn data-size)
    (let ((test-data (generate-sensor-data (or data-size *default-data-size*))))
      ;; Warmup runs
      (repeat *warmup-iterations*
        (lambda () (pipeline-fn test-data)))
      
      ;; Actual benchmark
      (let ((timings (map (lambda (_)
                           (let ((start-time (current-time-millis)))
                             (pipeline-fn test-data)
                             (- (current-time-millis) start-time)))
                         (range 0 *benchmark-iterations*))))
        
        ;; Calculate statistics
        (make-map
          "min-time" (apply min timings)
          "max-time" (apply max timings)
          "avg-time" (/ (apply + timings) (length timings))
          "throughput" (/ data-size (/ (apply min timings) 1000.0))  ; events/second
          "data-size" data-size))))
  
  ;; Generate realistic sensor data with various patterns
  (define (generate-sensor-data size)
    (let ((sensor-ids ["temp-001" "temp-002" "temp-003" 
                      "pres-001" "pres-002"
                      "hum-001" "hum-002"]))
      (map (lambda (i)
            (let* ((sensor-id (list-ref sensor-ids (modulo i (length sensor-ids))))
                   (base-time (* i 100))
                   (sensor-type (cond
                                 ((string-starts-with? sensor-id "temp-") "temperature")
                                 ((string-starts-with? sensor-id "pres-") "pressure")
                                 ((string-starts-with? sensor-id "hum-") "humidity")
                                 (else "unknown")))
                   (value (generate-sensor-value sensor-type i)))
              (make-sensor-reading
                sensor-id
                base-time
                value
                (make-map "type" sensor-type
                         "quality" (if (< (random) 0.95) "good" "poor")))))
           (range 0 size))))
  
  ;; Generate realistic sensor values with occasional anomalies
  (define (generate-sensor-value sensor-type index)
    (let ((anomaly-chance 0.05)  ; 5% chance of anomaly
          (is-anomaly (< (random) anomaly-chance)))
      (cond
        ((eq? sensor-type "temperature")
         (if is-anomaly
             (+ 45.0 (* (random) 20.0))  ; Anomaly: 45-65°C
             (+ 18.0 (* (random) 8.0))))  ; Normal: 18-26°C
        
        ((eq? sensor-type "pressure")
         (if is-anomaly
             (+ 1150.0 (* (random) 100.0))  ; Anomaly: 1150-1250 hPa
             (+ 1000.0 (* (random) 30.0))))  ; Normal: 1000-1030 hPa
        
        ((eq? sensor-type "humidity")
         (if is-anomaly
             (+ 110.0 (* (random) 20.0))  ; Anomaly: 110-130%
             (+ 40.0 (* (random) 30.0))))  ; Normal: 40-70%
        
        (else 0.0))))
  
  ;; Measure throughput in events per second
  (define (measure-throughput pipeline-fn data-stream)
    (let* ((start-time (current-time-millis))
           (result (pipeline-fn data-stream))
           (end-time (current-time-millis))
           (duration-ms (- end-time start-time))
           (duration-sec (/ duration-ms 1000.0))
           (throughput (/ (length data-stream) duration-sec)))
      (make-map
        "duration-ms" duration-ms
        "events-processed" (length data-stream)
        "throughput" throughput
        "anomalies-found" (length result))))
  
  ;; Compare different implementations
  (define (compare-implementations data-sizes)
    (map (lambda (size)
          (let ((results (make-map)))
            ;; Benchmark each version
            (map-set results "v1-naive" 
                    (benchmark-pipeline process-stream-v1 size))
            (map-set results "v2-contracts" 
                    (benchmark-pipeline process-stream-v2 size))
            (map-set results "v3-optimized" 
                    (benchmark-pipeline process-stream-v3 size))
            
            ;; For stream version, we need to convert to stream first
            (map-set results "v4-streams"
                    (let ((test-data (generate-sensor-data size)))
                      (benchmark-pipeline 
                        (lambda (data)
                          (stream-collect 
                            (process-stream-final 
                              (stream-from-list data))))
                        size)))
            
            (make-map "data-size" size "results" results)))
         data-sizes))
  
  ;; Pretty print benchmark results
  (define (print-benchmark-results results)
    (effect io print-line "")
    (effect io print-line "=== IoT Pipeline Benchmark Results ===")
    (effect io print-line "")
    
    (map (lambda (size-result)
          (let ((size (map-get size-result "data-size"))
                (versions (map-get size-result "results")))
            (effect io print-line 
              (string-format "Data size: {} events" size))
            (effect io print-line "")
            
            ;; Print each version's results
            (map (lambda (version-name)
                  (let ((stats (map-get versions version-name)))
                    (effect io print-line
                      (string-format "  {}: {:.0f} events/sec (avg: {:.1f}ms)"
                                    version-name
                                    (map-get stats "throughput")
                                    (map-get stats "avg-time")))))
                 ["v1-naive" "v2-contracts" "v3-optimized" "v4-streams"])
            
            (effect io print-line "")
            
            ;; Calculate speedup
            (let ((v1-throughput (map-get (map-get versions "v1-naive") "throughput"))
                  (v3-throughput (map-get (map-get versions "v3-optimized") "throughput")))
              (effect io print-line
                (string-format "  Optimization speedup: {:.1f}x"
                             (/ v3-throughput v1-throughput))))))
         results))
  
  ;; Helper functions
  (define (range start end)
    (if (>= start end)
        []
        (cons start (range (+ start 1) end))))
  
  (define (repeat n f)
    (if (<= n 0)
        nil
        (begin (f) (repeat (- n 1) f))))
  
  (define (modulo a b)
    (- a (* b (quotient a b))))
  
  (define (apply f args)
    (cond
      ((eq? f +) (fold-left + 0 args))
      ((eq? f min) (fold-left (lambda (a b) (if (< a b) a b)) 
                              (car args) (cdr args)))
      ((eq? f max) (fold-left (lambda (a b) (if (> a b) a b))
                              (car args) (cdr args)))
      (else (error "Unknown function for apply")))))