; Recursion and tail call optimization in FluentAI
; Demonstrates recursive patterns and tail-recursive implementations

; Simple recursion (not tail-recursive)
(letrec ((factorial
          (lambda (n)
            (if (<= n 1)
                1
                (* n (factorial (- n 1)))))))
  (print "5! =" (factorial 5)))

; Tail-recursive factorial with accumulator
(letrec ((factorial-tail
          (lambda (n acc)
            (if (<= n 1)
                acc
                (factorial-tail (- n 1) (* n acc))))))
  (print "10! =" (factorial-tail 10 1)))

; Fibonacci - naive recursive version
(letrec ((fib
          (lambda (n)
            (if (<= n 1)
                n
                (+ (fib (- n 1)) (fib (- n 2)))))))
  (print "fib(10) =" (fib 10)))

; Fibonacci - tail-recursive with two accumulators
(letrec ((fib-tail
          (lambda (n a b)
            (if (= n 0)
                a
                (fib-tail (- n 1) b (+ a b))))))
  (print "fib(20) =" (fib-tail 20 0 1)))

; Sum of list - non-tail-recursive
(letrec ((sum-list
          (lambda (lst)
            (match lst
              ((Nil) 0)
              ((Cons x xs) (+ x (sum-list xs)))))))
  (print "Sum of [1..5]:" (sum-list (list 1 2 3 4 5))))

; Sum of list - tail-recursive
(letrec ((sum-list-tail
          (lambda (lst acc)
            (match lst
              ((Nil) acc)
              ((Cons x xs) (sum-list-tail xs (+ acc x)))))))
  (print "Sum of [1..100]:" 
         (sum-list-tail (list 1 2 3 4 5 6 7 8 9 10) 0)))

; List reversal - tail-recursive
(letrec ((reverse-tail
          (lambda (lst acc)
            (match lst
              ((Nil) acc)
              ((Cons x xs) (reverse-tail xs (cons x acc)))))))
  (let ((original (list 1 2 3 4 5)))
    (print "Original:" original)
    (print "Reversed:" (reverse-tail original (list)))))

; Tree traversal - accumulator-based
(letrec ((sum-tree
          (lambda (tree)
            (letrec ((sum-helper
                      (lambda (tree acc)
                        (match tree
                          ((Leaf n) (+ acc n))
                          ((Node left right)
                            (sum-helper right 
                                       (sum-helper left acc)))))))
              (sum-helper tree 0)))))
  (let ((tree (Node (Node (Leaf 1) (Leaf 2))
                   (Node (Leaf 3) (Leaf 4)))))
    (print "Tree sum:" (sum-tree tree))))

; Mutual recursion - even/odd
(letrec ((is-even
          (lambda (n)
            (if (= n 0)
                true
                (is-odd (- n 1)))))
         (is-odd
          (lambda (n)
            (if (= n 0)
                false
                (is-even (- n 1))))))
  (print "is-even(10):" (is-even 10))
  (print "is-odd(10):" (is-odd 10)))

; Range generation - tail-recursive
(letrec ((range-tail
          (lambda (start end acc)
            (if (> start end)
                acc
                (range-tail start (- end 1) (cons end acc))))))
  (print "Range 1-10:" (range-tail 1 10 (list))))

; Map implementation - tail-recursive with continuation
(letrec ((map-tail
          (lambda (f lst acc)
            (match lst
              ((Nil) (reverse-tail acc (list)))
              ((Cons x xs) 
                (map-tail f xs (cons (f x) acc)))))))
  (print "Squares of [1..5]:"
         (map-tail (lambda (x) (* x x)) 
                   (list 1 2 3 4 5) 
                   (list))))

; Quick sort - tail-recursive with continuations
(letrec ((qsort
          (lambda (lst)
            (match lst
              ((Nil) (list))
              ((Cons pivot xs)
                (let ((less (filter (lambda (x) (< x pivot)) xs))
                      (greater (filter (lambda (x) (>= x pivot)) xs)))
                  (append (qsort less)
                          (cons pivot (qsort greater)))))))))
  (let ((unsorted (list 3 1 4 1 5 9 2 6)))
    (print "Unsorted:" unsorted)
    (print "Sorted:" (qsort unsorted))))