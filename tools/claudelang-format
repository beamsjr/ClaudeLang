#!/usr/bin/env python3
"""
ClaudeLang Code Formatter CLI

Usage:
    claudelang-format [options] <file>...
    claudelang-format --stdin

Options:
    -i, --in-place     Format files in place
    -c, --check        Check if files are formatted (exit 1 if not)
    --indent <n>       Set indentation width (default: 2)
    --line-length <n>  Set maximum line length (default: 80)
    --stdin            Read from stdin and write to stdout
    -h, --help         Show this help message
"""

import sys
import os
import argparse
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from src.formatter import format_code, format_file, FormatOptions


def main():
    parser = argparse.ArgumentParser(
        description='Format ClaudeLang source code',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        'files',
        nargs='*',
        help='Files to format'
    )
    
    parser.add_argument(
        '-i', '--in-place',
        action='store_true',
        help='Format files in place'
    )
    
    parser.add_argument(
        '-c', '--check',
        action='store_true',
        help='Check if files are formatted (exit 1 if not)'
    )
    
    parser.add_argument(
        '--indent',
        type=int,
        default=2,
        help='Indentation width (default: 2)'
    )
    
    parser.add_argument(
        '--line-length',
        type=int,
        default=80,
        help='Maximum line length (default: 80)'
    )
    
    parser.add_argument(
        '--stdin',
        action='store_true',
        help='Read from stdin and write to stdout'
    )
    
    parser.add_argument(
        '--no-align-let',
        action='store_true',
        help='Disable let binding alignment'
    )
    
    parser.add_argument(
        '--no-align-match',
        action='store_true',
        help='Disable match branch alignment'
    )
    
    args = parser.parse_args()
    
    # Create format options
    options = FormatOptions(
        indent_width=args.indent,
        max_line_length=args.line_length,
        align_let_bindings=not args.no_align_let,
        align_match_branches=not args.no_align_match
    )
    
    # Handle stdin mode
    if args.stdin:
        source = sys.stdin.read()
        formatted = format_code(source, options)
        sys.stdout.write(formatted)
        return 0
    
    # Require files if not reading from stdin
    if not args.files:
        parser.error('No files specified')
    
    # Process files
    needs_formatting = []
    errors = []
    
    for filename in args.files:
        path = Path(filename)
        
        if not path.exists():
            errors.append(f"Error: File not found: {filename}")
            continue
        
        if not path.is_file():
            errors.append(f"Error: Not a file: {filename}")
            continue
        
        try:
            with open(path, 'r') as f:
                source = f.read()
            
            formatted = format_code(source, options)
            
            if args.check:
                # Check mode - just report if formatting needed
                if source != formatted:
                    needs_formatting.append(filename)
            elif args.in_place:
                # In-place mode - write back to file
                if source != formatted:
                    with open(path, 'w') as f:
                        f.write(formatted)
                    print(f"Formatted: {filename}")
                else:
                    print(f"Already formatted: {filename}")
            else:
                # Default mode - print to stdout
                sys.stdout.write(formatted)
                
        except Exception as e:
            errors.append(f"Error formatting {filename}: {e}")
    
    # Print errors
    for error in errors:
        print(error, file=sys.stderr)
    
    # Handle check mode results
    if args.check and needs_formatting:
        print(f"\nThe following files need formatting:", file=sys.stderr)
        for filename in needs_formatting:
            print(f"  {filename}", file=sys.stderr)
        return 1
    
    return 1 if errors else 0


if __name__ == '__main__':
    sys.exit(main())